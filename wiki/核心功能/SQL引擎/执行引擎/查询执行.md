# 查询执行

<cite>
**本文档引用的文件**   
- [YieldableLocalQuery.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableLocalQuery.java)
- [Select.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\Select.java)
- [YieldableSelect.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableSelect.java)
- [Optimizer.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\Optimizer.java)
- [Plan.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\Plan.java)
- [TableFilter.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\TableFilter.java)
- [QOperator.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\QOperator.java)
- [QFlat.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\QFlat.java)
- [QDistinct.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\QDistinct.java)
- [YieldableBase.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\executor\YieldableBase.java)
- [Index.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\index\Index.java)
- [LocalResult.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\result\LocalResult.java)
</cite>

## 目录
1. [查询执行概述](#查询执行概述)
2. [Select查询执行流程](#select查询执行流程)
3. [可暂停查询执行机制](#可暂停查询执行机制)
4. [查询执行计划生成与优化](#查询执行计划生成与优化)
5. [查询执行与存储引擎交互](#查询执行与存储引擎交互)
6. [查询执行时序图](#查询执行时序图)

## 查询执行概述

查询执行是数据库系统的核心功能之一，负责将SQL查询语句转换为实际的数据访问操作。Lealone数据库的查询执行框架设计精巧，支持从查询解析、执行计划生成、优化到结果返回的完整生命周期管理。该框架特别注重高并发场景下的性能表现，通过可暂停执行机制确保系统在处理复杂查询时仍能保持良好的响应性。

查询执行框架主要由以下几个核心组件构成：
- **查询解析器**：负责将SQL语句解析为抽象语法树
- **查询优化器**：生成最优的查询执行计划
- **执行引擎**：根据执行计划执行查询操作
- **结果处理器**：管理查询结果的生成和返回

这些组件协同工作，确保查询能够高效、准确地执行。

**Section sources**
- [Select.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\Select.java#L1-L1026)
- [YieldableSelect.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableSelect.java#L1-L213)

## Select查询执行流程

Select查询的执行流程从客户端发送查询请求开始，经过多个阶段最终返回结果。整个流程可以分为以下几个关键阶段：

1. **查询初始化**：解析SQL语句并初始化查询对象
2. **执行计划生成**：优化器根据查询条件生成最优执行计划
3. **查询执行**：执行引擎按照执行计划访问数据
4. **结果处理**：收集和处理查询结果
5. **结果返回**：将结果返回给客户端

在Lealone数据库中，Select查询的执行流程通过`Select`类实现。该类负责管理查询的整个生命周期，从初始化到结果返回。查询执行的核心逻辑位于`prepare()`和`query()`方法中，其中`prepare()`方法负责执行计划的生成和优化，而`query()`方法则负责实际的查询执行。

```mermaid
flowchart TD
A[客户端发送查询] --> B[查询解析]
B --> C[执行计划生成]
C --> D[查询执行]
D --> E[结果处理]
E --> F[结果返回]
F --> G[客户端接收结果]
```

**Diagram sources **
- [Select.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\Select.java#L1-L1026)

**Section sources**
- [Select.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\Select.java#L1-L1026)
- [YieldableSelect.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableSelect.java#L1-L213)

## 可暂停查询执行机制

Lealone数据库通过`YieldableLocalQuery`和`YieldableSelect`类实现了查询的可暂停执行机制。这种机制允许长时间运行的查询在执行过程中主动让出CPU资源，从而避免阻塞其他查询的执行，提高系统的整体并发性能。

### YieldableLocalQuery实现

`YieldableLocalQuery`是可暂停查询的基础实现，它继承自`YieldableQueryBase`类。该类的核心方法是`executeInternal()`，其执行流程如下：

```mermaid
flowchart TD
A[开始执行] --> B[设置会话状态为运行中]
B --> C[执行查询]
C --> D[设置查询结果]
D --> E[设置会话状态为完成]
E --> F[结束执行]
```

**Diagram sources **
- [YieldableLocalQuery.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableLocalQuery.java#L1-L28)

### YieldableSelect实现

`YieldableSelect`类提供了更高级的可暂停查询功能，支持OLAP（在线分析处理）模式的查询执行。该类通过`yieldIfNeeded()`方法实现查询的可暂停特性：

```mer
flowchart TD
    A[检查是否需要暂停] --> B{行数超过阈值?}
    B -->|是| C[创建OLAP操作符]
    C --> D[让出执行权]
    D --> E[设置会话状态为暂停]
    E --> F[返回true]
    B -->|否| G[调用父类方法]
    G --> H[返回结果]
```

**Diagram sources **
- [YieldableSelect.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableSelect.java#L1-L213)

`YieldableSelect`类还实现了`createQueryOperator()`方法，根据查询类型选择合适的操作符：

```mermaid
flowchart TD
A[创建查询操作符] --> B{是否有缓存结果?}
B --> |是| C[创建QCache操作符]
B --> |否| D[检查行数限制]
D --> E{行数限制为0?}
E --> |是| F[创建QEmpty操作符]
E --> |否| G[检查是否为快速聚合查询]
G --> H{是快速聚合查询?}
H --> |是| I[创建QAggregateQuick操作符]
H --> |否| J[检查是否为分组查询]
J --> K{是分组查询?}
K --> |是| L[检查是否为分组排序查询]
L --> M{是分组排序查询?}
M --> |是| N[创建QGroupSorted操作符]
M --> |否| O[创建QGroup操作符]
K --> |否| P[检查是否为去重查询]
P --> Q{是去重查询?}
Q --> |是| R[创建QDistinct操作符]
Q --> |否| S[创建QFlat操作符]
```

**Diagram sources **
- [YieldableSelect.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableSelect.java#L120-L162)

**Section sources**
- [YieldableLocalQuery.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableLocalQuery.java#L1-L28)
- [YieldableSelect.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableSelect.java#L1-L213)
- [YieldableBase.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\executor\YieldableBase.java#L1-L193)

## 查询执行计划生成与优化

查询执行计划的生成与优化是数据库性能的关键。Lealone数据库通过`Optimizer`类实现了高效的查询优化器，能够根据查询条件和数据特征生成最优的执行计划。

### 执行计划生成

执行计划的生成过程由`Optimizer`类的`optimize()`方法完成。该方法首先调用`calculateBestPlan()`计算最佳执行计划，然后对计划进行条件优化：

```mermaid
classDiagram
class Optimizer {
+TableFilter[] filters
+ServerSession session
+Plan bestPlan
+double cost
+Random random
+long start
+BitField switched
+Optimizer(TableFilter[], ServerSession)
+double getCost()
+TableFilter optimize()
+void calculateBestPlan()
+boolean testPlan(TableFilter[])
+boolean canStop(int)
+void calculateBruteForceAll()
+void calculateBruteForceSome()
+void calculateGenetic()
+int getMaxBruteForceFilters(int)
+static PlanItem getBestPlanItem(ServerSession, int[], Table, SortOrder)
}
class Plan {
+TableFilter[] filters
+HashMap<TableFilter, PlanItem> planItems
+TableFilter[] allFilters
+Plan(TableFilter[], int)
+PlanItem getItem(TableFilter)
+TableFilter[] getFilters()
+void optimizeConditions()
+double calculateCost(ServerSession)
+void setEvaluatable(TableFilter, boolean)
}
class PlanItem {
+Index index
+double cost
+PlanItem nestedJoinPlan
+PlanItem joinPlan
+PlanItem()
+void setIndex(Index)
+Index getIndex()
+void setNestedJoinPlan(PlanItem)
+PlanItem getNestedJoinPlan()
+void setJoinPlan(PlanItem)
+PlanItem getJoinPlan()
}
Optimizer --> Plan : "生成"
Optimizer --> PlanItem : "使用"
Plan --> PlanItem : "包含"
```

**Diagram sources **
- [Optimizer.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\Optimizer.java#L1-L282)
- [Plan.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\Plan.java#L1-L116)

### 查询优化策略

Lealone数据库实现了多种查询优化策略，包括：

1. **索引选择优化**：根据查询条件选择最优索引
2. **排序优化**：利用索引的有序性避免额外排序
3. **去重优化**：为DISTINCT查询选择合适的索引
4. **分组优化**：为GROUP BY查询选择分组排序索引

这些优化策略在`Select`类的`prepare()`方法中实现：

```mermaid
flowchart TD
A[准备执行计划] --> B{是否为单表查询?}
B --> |是| C[调用preparePlan()]
B --> |否| D[创建优化器]
D --> E[调用优化器的optimize()]
E --> F[设置可评估性]
F --> G[返回成本]
C --> H[返回成本]
G --> I[检查DISTINCT优化]
I --> J{满足DISTINCT优化条件?}
J --> |是| K[调用optimizeDistinct()]
J --> |否| L[检查排序优化]
L --> M{满足排序优化条件?}
M --> |是| N[调用optimizeSort()]
M --> |否| O[检查分组优化]
O --> P{有分组索引?}
P --> |是| Q[设置分组排序查询]
P --> |否| R[完成准备]
```

**Diagram sources **
- [Select.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\Select.java#L538-L557)

**Section sources**
- [Optimizer.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\Optimizer.java#L1-L282)
- [Plan.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\Plan.java#L1-L116)
- [Select.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\Select.java#L408-L557)

## 查询执行与存储引擎交互

查询执行过程中与存储引擎的交互主要通过`TableFilter`和`Index`接口实现。`TableFilter`类负责管理表的访问，而`Index`接口定义了索引的操作方法。

### TableFilter实现

`TableFilter`类是查询执行与存储引擎交互的核心组件，它负责管理表的访问和查询条件的处理：

```mermaid
classDiagram
class TableFilter {
+ServerSession session
+Table table
+String alias
+Index index
+int scanCount
+boolean evaluatable
+boolean used
+IndexCursor cursor
+ArrayList<IndexCondition> indexConditions
+Expression filterCondition
+Expression joinCondition
+SearchRow currentSearchRow
+Row current
+int state
+TableFilter join
+boolean joinOuter
+TableFilter nestedJoin
+ArrayList<Column> naturalJoinColumns
+boolean foundOne
+Expression fullCondition
+int hashCode
+int[] columnIndexes
+TableFilter(ServerSession, Table, String, boolean, Select)
+Select getSelect()
+Table getTable()
+IndexCursor getCursor()
+PlanItem getBestPlanItem(ServerSession, int)
+void setPlanItem(PlanItem)
+void prepare()
+PlanItem preparePlan(ServerSession, int)
+void startQuery(ServerSession)
+void reset()
+boolean next()
+void setNullRow()
+void checkTimeout()
+boolean isOk(Expression)
+Row get()
+void set(Row)
+String getTableAlias()
+void addIndexCondition(IndexCondition)
+void addFilterCondition(Expression, boolean)
+Expression createCondition(Expression, Expression)
+void addJoin(TableFilter, boolean, Expression)
+void mapAndAddFilter(Expression)
+TableFilter getJoin()
+boolean isJoinOuter()
+boolean isJoinOuterIndirect()
+String getPlanSQL(boolean)
+void removeUnusableIndexConditions()
+Index getIndex()
+void setIndex(Index)
+void setUsed(boolean)
+boolean isUsed()
+void setSession(ServerSession)
+void removeJoin()
+Expression getJoinCondition()
+void removeJoinCondition()
+Expression getFilterCondition()
+void removeFilterCondition()
+void setFullCondition(Expression)
+void optimizeFullCondition()
+void setEvaluatable(TableFilter, boolean)
+void setEvaluatable(boolean)
+boolean isEvaluatable()
+String getSchemaName()
+Column[] getColumns()
+Column[] getSystemColumns()
}
class IndexCursor {
+TableFilter tableFilter
+Index index
+SearchRow lastSearchRow
+boolean alwaysFalse
+IndexCursor(TableFilter)
+void find(ServerSession, ArrayList<IndexCondition>)
+boolean isAlwaysFalse()
+boolean next()
+SearchRow getSearchRow()
+Row get(int[])
}
TableFilter --> IndexCursor : "包含"
TableFilter --> Index : "使用"
TableFilter --> IndexCondition : "包含"
```

**Diagram sources **
- [TableFilter.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\TableFilter.java#L1-L1006)

### 索引操作

`Index`接口定义了索引的基本操作方法，包括数据查找、插入、删除等：

```mermaid
classDiagram
class Index {
<<interface>>
+Table getTable()
+IndexType getIndexType()
+IndexColumn[] getIndexColumns()
+Column[] getColumns()
+int[] getColumnIds()
+int getColumnIndex(Column)
+String getPlanSQL()
+void add(ServerSession, Row, AsyncResultHandler)
+void update(ServerSession, Row, Row, Value[], int[], boolean, AsyncResultHandler)
+void remove(ServerSession, Row, Value[], boolean, AsyncResultHandler)
+Cursor find(ServerSession, SearchRow, SearchRow)
+Cursor find(ServerSession, CursorParameters)
+boolean canGetFirstOrLast()
+SearchRow findFirstOrLast(ServerSession, boolean)
+boolean supportsDistinctQuery()
+Cursor findDistinct(ServerSession)
+boolean canScan()
+boolean isRowIdIndex()
+Row getRow(ServerSession, long)
+int compareRows(SearchRow, SearchRow)
+double getCost(ServerSession, int[], SortOrder)
+void setLastIndexedRowKey(Long)
+Long getLastIndexedRowKey()
+void setBuilding(boolean)
+boolean isBuilding()
+boolean isClosed()
+void close(ServerSession)
+void remove(ServerSession)
+void truncate(ServerSession)
+long getDiskSpaceUsed()
+long getMemorySpaceUsed()
+boolean needRebuild()
+IndexOperator getIndexOperator()
+void setIndexOperator(IndexOperator)
}
class Cursor {
<<interface>>
+boolean next()
+SearchRow getSearchRow()
+Row get(int[])
+void close()
}
class IndexOperator {
<<interface>>
+void start()
+void run()
+void stop()
+boolean isStopped()
}
Index --> Cursor : "返回"
Index --> IndexOperator : "包含"
```

**Diagram sources **
- [Index.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\index\Index.java#L1-L268)

### 查询结果管理

查询结果通过`LocalResult`类进行管理，该类负责结果的存储、排序和去重：

```mermaid
classDiagram
class LocalResult {
+int maxMemoryRows
+ServerSession session
+int visibleColumnCount
+List<String[]> rawExpressionInfoList
+IExpression[] expressions
+int rowId
+int rowCount
+ArrayList<Value[]> rows
+SortOrder sort
+ValueHashMap<Value[]> distinctRows
+Value[] currentRow
+int offset
+int limit
+ResultExternal external
+int diskOffset
+boolean distinct
+boolean closed
+LocalResult()
+LocalResult(ServerSession, IExpression[], int)
+LocalResult(ServerSession, IExpression[], int, List<String[]>)
+LocalResult createShallowCopy(ServerSession)
+void setSortOrder(SortOrder)
+void setDistinct()
+void removeDistinct(Value[])
+boolean containsDistinct(Value[])
+void reset()
+Value[] currentRow()
+boolean next()
+int getRowId()
+boolean addRow(Value[])
+void done()
+int getRowCount()
+void setLimit(int)
+void close()
+String getAlias(int)
+String getTableName(int)
+String getSchemaName(int)
+int getDisplaySize(int)
+String getColumnName(int)
+int getColumnType(int)
+long getColumnPrecision(int)
+int getNullable(int)
+boolean isAutoIncrement(int)
+int getColumnScale(int)
+void setOffset(int)
+boolean isClosed()
+int getFetchSize()
+void setFetchSize(int)
+static LocalResult read(ServerSession, IExpression[], ResultSet, int)
}
class ResultExternal {
<<interface>>
+boolean next()
+void reset()
+int addRow(Value[])
+int addRows(List<Value[]>)
+void done()
+void close()
+boolean containsDistinct(Value[])
+int removeDistinct(Value[])
+ResultExternal createShallowCopy()
}
class SortOrder {
+int[] sortTypes
+int[] queryColumnIndexes
+boolean[] sortNullsLast
+SortOrder(int[], int[], boolean[])
+void sort(List<Value[]>)
+void sort(List<Value[]>, int, int)
}
LocalResult --> ResultExternal : "使用"
LocalResult --> SortOrder : "使用"
```

**Diagram sources **
- [LocalResult.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\result\LocalResult.java#L1-L494)

**Section sources**
- [TableFilter.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\TableFilter.java#L1-L1006)
- [Index.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\index\Index.java#L1-L268)
- [LocalResult.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\result\LocalResult.java#L1-L494)

## 查询执行时序图

以下是Select查询执行的完整时序图，展示了从查询开始到结果返回的关键阶段和状态转换：

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Session as "会话"
participant Yieldable as "可暂停查询"
participant Select as "Select查询"
participant Optimizer as "优化器"
participant TableFilter as "表过滤器"
participant Index as "索引"
participant Storage as "存储引擎"
participant Result as "结果处理器"
Client->>Session : 发送查询请求
Session->>Yieldable : 创建可暂停查询
Yieldable->>Yieldable : startInternal()
Yieldable->>Select : fireBeforeSelectTriggers()
Yieldable->>Yieldable : createQueryOperator()
Yieldable->>Select : prepare()
Select->>Optimizer : optimize()
Optimizer->>Optimizer : calculateBestPlan()
Optimizer->>TableFilter : getBestPlanItem()
TableFilter->>Index : getCost()
Index-->>TableFilter : 返回成本
TableFilter-->>Optimizer : 返回计划项
Optimizer-->>Select : 返回最佳计划
Select->>Select : 优化执行计划
Select->>Yieldable : 返回查询操作符
Yieldable->>Yieldable : executeInternal()
loop 执行查询
Yieldable->>Yieldable : queryOperator.run()
Yieldable->>TableFilter : next()
TableFilter->>Index : find()
Index->>Storage : 读取数据页
Storage-->>Index : 返回数据
Index-->>TableFilter : 返回游标
TableFilter->>TableFilter : 检查条件
TableFilter-->>Yieldable : 返回行
Yieldable->>Result : addRow()
Yieldable->>Yieldable : yieldIfNeeded()
alt 需要暂停
Yieldable-->>Session : 让出执行权
Session-->>Client : 暂停状态
Client-->>Session : 继续请求
Session->>Yieldable : 恢复执行
end
end
Yieldable->>Result : done()
Result->>Result : 排序/去重
Result-->>Yieldable : 返回结果
Yieldable-->>Session : 设置完成状态
Session-->>Client : 返回查询结果
```

**Diagram sources **
- [YieldableSelect.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableSelect.java#L89-L117)
- [Select.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\Select.java#L738-L739)
- [TableFilter.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\TableFilter.java#L308-L393)
- [Index.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\index\Index.java#L120-L122)
- [LocalResult.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\result\LocalResult.java#L266-L309)

**Section sources**
- [YieldableSelect.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\YieldableSelect.java#L89-L117)
- [Select.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\query\Select.java#L738-L739)
- [TableFilter.java](https://github.com/lealone/Lealone/blob/master/lealone-sql\src\main\java\com\lealone\sql\optimizer\TableFilter.java#L308-L393)
- [Index.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\index\Index.java#L120-L122)
- [LocalResult.java](https://github.com/lealone/Lealone/blob/master/lealone-db\src\main\java\com\lealone\db\result\LocalResult.java#L266-L309)